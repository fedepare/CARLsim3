<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>CARLsim: Chapter 10: ECJ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="CARLsimStyles.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CARLsim
   &#160;<span id="projectnumber">3.1.3</span>
   </div>
   <div id="projectbrief">CARLsim: a GPU-accelerated SNN simulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup1.html"><span>Tutorial</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ch10_ecj.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Chapter 10: ECJ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ch10s1_overview">CARLsim-ECJ Parameter-Tuning Framework Overview</a></li>
<li class="level1"><a href="#ch10s2_installation">10.2 Installation</a></li>
<li class="level1"><a href="#ch10s3_usage">10.3 Example ECJ Parameter File</a></li>
<li class="level1"><a href="#ch10s_ecj_options">10.4 ECJ Extensions</a><ul><li class="level2"><a href="#ch10s_ecj_options_simpleGroupedEvaluator">10.4.1 SimpleGroupedEvaluator</a></li>
<li class="level2"><a href="#ch10s_ecj_options_commandProblem">10.4.2 CommandProblem</a></li>
<li class="level2"><a href="#ch10s_ecj_options_objective">10.4.3 ObjectiveFunction</a></li>
<li class="level2"><a href="#ch10s_ecj_options_dynamicArguments">10.4.4 DynamicArguments and Multi-GPU Evolution</a></li>
<li class="level2"><a href="#ch10s_ecj_options_statistics">10.4.5 Recording Statistics</a></li>
</ul>
</li>
<li class="level1"><a href="#ch10s_ecj_tricks">10.5 Tips and Tricks</a><ul><li class="level2"><a href="#ch10s_ecj_tricks_getBest">10.5.1 Retrieving Genomes of the Best Individuals</a></li>
<li class="level2"><a href="#ch10s_ecj_tricks_withoutECJ">10.5.2 Evaluating Individuals Outside of ECJ</a></li>
</ul>
</li>
<li class="level1"><a href="#ch10s4_references">References</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ch10s1_overview"></a>
CARLsim-ECJ Parameter-Tuning Framework Overview</h1>
<p><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> now has a software interface to an evolutionary computation system written in Java (ECJ) (Luke et al., 2006) to provide an automated parameter tuning framework. We found that an automated tuning framework became increasingly useful as our SNN models became more complex. Evolutionary Algorithms (EAs) enable flexible parameter tuning by means of optimizing a generic fitness function. The first version of the automated parameter-tuning framework used an EA library called Evolving Objects (EO) as the EA engine (Carlson et al., 2014). ECJ was chosen to supercede EO because it is under active development (Linux), supports multi-threading, has excellent documentation, and implements a variety of EAs (Luke at al., 2006).</p>
<div class="image">
<img src="10_ecj.png" alt="10_ecj.png"/>
<div class="caption">
Fig. 1. General approach to parameter tuning. ECJ performs the EA and passes the current generation of parameters (red arrow) to CARLsim for evaluation using the parameter tuning interface (PTI) code. CARLsim assigns each parameter set to an SNN and evaluates all the individuals in parallel, passing the fitness values back to ECJ for selection of individuals in the next generation (black arrow).</div></div>
<p> Source: Beyeler et al., 2015</p>
<p>Fig. 1 shows the general approach of the automated parameter tuning framework. ECJ implements an EA with a parameter file that includes: EA parameters, the number of individuals per generation, and parameter ranges. Each step of the EA is executed by ECJ except for the evaluation of the fitness function, which is completed by <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a>. <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> evaluates the fitness function in parallel by running multiple SNN individuals simultaneously on the GPU, where the bulk of the computations occur. The majority of the execution time is spent running CARLsimâ€™s optimized C++/CUDA code, and the overhead created by ECJ's operations is negligible.</p>
<p>PTI consists of two components which serve to define a standard interface for executing <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> models with ECJ. On the C++ side, PTI provides a small library that helps load a population of parameter vectors, and provides a standard mechanism for returning information about their performance (such as a fitness value) after the simulation has completed. On the ECJ side, PTI provides a Jar file with a number of ECJ extensions. These extensions allow ECJ to easily invoke and communicate with an external simulator when an evolutionary algorithm is launched. Communcation between the ECJ process and the simulator processes it launches is effected automatically via standard UNIX input/output streams.</p>
<p>In a typical usage scenario, at the beginning of every generation of the evolutionary algorithm, the parameters to be tuned are passed from ECJ to an SNN model that has been implemented in <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a>, and which uses the PTI interface to define its input-output behavior. The model evaluates individuals in parallel and returns the resulting fitness values to ECJ via standard streams. The tuning framework allows users to tune virtually any SNN parameter, while the fitness functions can be written to depend on the neuronal activity or synaptic weights of the SNN.</p>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h1><a class="anchor" id="ch10s2_installation"></a>
10.2 Installation</h1>
<p>The current version of the <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> paramter-tuning interface (PTI) uses Evolutionary Computations in Java (ECJ) (version 22 or greater is required). For information on how to install ECJ, please go <a href="http://cs.gmu.edu/~eclab/projects/ecj/">here</a>.</p>
<p>After ECJ version 22 or greater has been installed the user then needs to set the <code>ECJ_JAR</code> and <code>ECJ_PTI_DIR</code> environment variables in either the .bashrc file or the user.mk file located in the tools/ecj_pti subdirectory. The <code>ECJ_JAR</code> environment variable points to the current installation location of the ECJ jar file. The <code>ECJ_PTI_DIR</code> environment variable points to the desired location of the CARLsim-ECJ PTI code. The code below shows the default values that can be changed in the user.mk file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#------------------------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># CARLsim/ECJ Parameter Tuning Interface Options</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#------------------------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># path of evolutionary computation in java installation for ECJ-PTI CARLsim</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># support</span></div>
<div class="line"><span class="preprocessor"></span>ECJ_JAR ?= /opt/ecj/jar/ecj.22.jar</div>
<div class="line">ECJ_PTI_DIR ?= /opt/CARL/carlsim_ecj_pti</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The user should note that the user.mk file in the tools/ecj_pti directory is distinct from the user.mk file in the main carlsim directory and not confuse them. Here we are configuring the user.mk file in the tools/ecj_pti subdirectory.</dd></dl>
<p>As an alternative, users can set these environment variables in their .bashrc files if they are using a Unix-like OS. The following lines would be appended to .bashrc.</p>
<div class="fragment"><div class="line">export ECJ_JAR = /opt/ecj/jar/ecj.22.jar</div>
<div class="line">export ECJ_PTI_DIR = /opt/CARL/carlsim_ecj_pti</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You may have to open a new shell or reboot to get export these variables.</dd></dl>
<p>Once the environment variables have been set. Navigate to tools/ecj_pti and run:</p>
<div class="fragment"><div class="line">make &amp;&amp; sudo make install</div>
</div><!-- fragment --><p>This will install the CARLsim-ECJ PTI library into the location pointed to by <code>ECJ_PTI_DIR</code>. Both the static C++ library and the Jar with the Java extensions for ECJ will be installed in this directory.</p>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h1><a class="anchor" id="ch10s3_usage"></a>
10.3 Example ECJ Parameter File</h1>
<p>To operate an evolutionary algorithm with ECJ, users define a parameter file that details all the algorithm components, parameters, and data-logging mechanisms that will go into the experiment. Creating experiments in this way is a form of declarative programming or <a href="https://en.wikipedia.org/wiki/Inversion_of_control">inversion of control</a>. This paradigm offers a great deal of flexibility and makes automation of experiments easy in many ways, but it can have a steep learning curve for users who aren't accustomed to programming in this way.</p>
<p>A thorough introduction to using ECJ and its parameter language is beyond the scope of <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a>'s documentation. We encourage <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> users to make use of the ECJ tutorials and the fantastic manual that Sean Luke maintains over on the <a href="http://cs.gmu.edu/~eclab/projects/ecj/">ECJ website</a>.</p>
<p>In general, to use the CARLsim-ECJ PTI, users will create an SNN modeled after the tutorial program found in <a class="el" href="tut7_pti.html">Tutorial 7: Parameter Tuning Interface (PTI)</a>. This program is responsible for reading a collection of parameters, instantiating a number of neural networks, executing them, and returning information about the behavior of each parameterized network (typically a scalar fitness value).</p>
<p>The user then must configure an ECJ parameter file defining the evolutionary search mechanism that will be used to search the parameter space for high-performing network configurations. Here we give a few relevant parts of an example parameter file that you may customize to your own purposes:</p>
<div class="fragment"><div class="line">parent.0 =                              @ec.simple.SimpleEvolutionState simple.params</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Modifications to the Simple EA boiler plate</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># =========================</span></div>
<div class="line"><span class="preprocessor"></span>eval =                  ecjapp.eval.SimpleGroupedEvaluator</div>
<div class="line">generations =               50</div>
<div class="line">pop.subpop.0.size =  10</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Set up our evolutionary algorithm</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># =========================</span></div>
<div class="line"><span class="preprocessor"></span>pop.subpop.0.species =                  ec.vector.FloatVectorSpecies</div>
<div class="line">pop.subpop.0.species.pipe =             ec.vector.breed.VectorMutationPipeline</div>
<div class="line">pop.subpop.0.species.pipe.likelihood =  1.0</div>
<div class="line">pop.subpop.0.species.pipe.source.0 =    ec.vector.breed.VectorCrossoverPipeline</div>
<div class="line">pop.subpop.0.species.pipe.source.0.likelihood   = 0.9</div>
<div class="line">pop.subpop.0.species.pipe.source.0.source.0 = ec.select.TournamentSelection</div>
<div class="line"><span class="preprocessor">#pop.subpop.0.species.pipe.source.0.source.0 = ec.es.ESSelection</span></div>
<div class="line"><span class="preprocessor"></span>pop.subpop.0.species.pipe.source.0.source.1 = same</div>
<div class="line">select.tournament.size =                2</div>
<div class="line">pop.subpop.0.species.ind =              ec.vector.DoubleVectorIndividual</div>
<div class="line">pop.subpop.0.species.fitness =          ec.simple.SimpleFitness</div>
<div class="line">pop.subpop.0.species.genome-size =      4</div>
<div class="line"></div>
<div class="line">pop.subpop.0.species.min-gene =         0.0005</div>
<div class="line">pop.subpop.0.species.max-gene =         0.5</div>
<div class="line">pop.subpop.0.species.mutation-type =    gauss</div>
<div class="line">pop.subpop.0.species.mutation-stdev =   0.1</div>
<div class="line">pop.subpop.0.species.mutation-bounded = <span class="keyword">true</span></div>
<div class="line">pop.subpop.0.species.mutation-prob =    0.4</div>
<div class="line">pop.subpop.0.species.crossover-likelihood =0.4</div>
<div class="line">#pop.subpop.0.species.crossover-prob=   0.9</div>
<div class="line">pop.subpop.0.species.crossover-type =   two</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># breed options</span></div>
<div class="line"><span class="preprocessor"></span>breed =              ec.es.MuPlusLambdaBreeder</div>
<div class="line">breed.elite.0 = 1</div>
<div class="line">breed.reevaluate-elites.0 = <span class="keyword">false</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># evolution strategies options</span></div>
<div class="line"><span class="preprocessor"></span>es.mu.0 =            5</div>
<div class="line">es.lambda.0 =        5</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Termination condition</span></div>
<div class="line"><span class="preprocessor"></span>quit-on-run-complete = <span class="keyword">true</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Set up external fitness evaluation</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># =========================</span></div>
<div class="line"><span class="preprocessor"></span>eval.problem.objective.idealFitnessValue = 0.333</div>
<div class="line">eval.problem =                          ecjapp.eval.problem.CommandProblem</div>
<div class="line">eval.problem.objective =                ecjapp.eval.problem.objective.StringToDoubleObjective</div>
<div class="line">eval.problem.simulationCommand =        $carlsim_tuneFiringRatesECJ</div>
</div><!-- fragment --><p>It's probably easiest to start with this ECJ parameter file and modify it to your project's needs. The particular variables the user needs to edit are:</p>
<p><code>eval.problem.simulationCommand</code>: which is the name of the carlsim binary ECJ executes every generation to evaluate the fitness function. The $ sign means the path is relative to the location of the parameter file.</p>
<p><code>generations</code>: number of maximum generations to run.</p>
<p><code>pop.subpop.0.size</code>: number of individuals in each generation.</p>
<p><code>pop.subpop.0.species.genome-size</code>: total number of parameters to be tuned in each individual.</p>
<p><code>pop.subpop.0.species.min-gene</code>: default minimum range value for all parameters to be tuned</p>
<p><code>pop.subpop.0.species.max-gene</code>: default maximum range value for all parameters to be tuned</p>
<p>To specify the parameter range for each parameter individually, you define min-gene and max.gene values for additional pop.subpop members as is shown in the code below:</p>
<div class="fragment"><div class="line">pop.subpop.0.species.min-gene.0=0.0004</div>
<div class="line">pop.subpop.0.species.max-gene.0=0.004</div>
<div class="line">pop.subpop.0.species.min-gene.1=0.00005</div>
<div class="line">pop.subpop.0.species.max-gene.1=0.0005</div>
<div class="line">pop.subpop.0.species.min-gene.2=0.01</div>
<div class="line">pop.subpop.0.species.max-gene.2=0.1</div>
<div class="line">pop.subpop.0.species.min-gene.3=0.1</div>
<div class="line">pop.subpop.0.species.max-gene.3=0.2</div>
</div><!-- fragment --><p>However,you still need to keep the <code>pop.subpop.0.species.min-gene</code> and <code>pop.subpop.0.species.max-gene</code> in the parameter file.</p>
<p>for more information about the ECJ configuration file, please visit the ECJ <a href="http://cs.gmu.edu/~eclab/projects/ecj/">homepage</a>.</p>
<p>Users then need to implement their own <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> evaluation function. The overall structure is as follows. A specific Experiment class is implemented and inherited from the base Experiment class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TuneFiringRatesECJExperiment : <span class="keyword">public</span> Experiment {</div>
</div><!-- fragment --><p>The only class functions functions are the default class constructor and the run function. The run function is where <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> code is written and executed. At the final step, the fitness values are output back to ECJ using standard Linux streams.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> run(<span class="keyword">const</span> ParameterInstances &amp;parameters, std::ostream &amp;outputStream)<span class="keyword"> const </span>{</div>
<div class="line">...</div>
<div class="line">CARLsim* <span class="keyword">const</span> network = <span class="keyword">new</span> <a class="code" href="classCARLsim.html">CARLsim</a>(<span class="stringliteral">&quot;tuneFiringRatesECJ&quot;</span>, <a class="code" href="carlsim__datastructures_8h.html#a14838da6840920e8872a5620470f1522a0b5ee5e90bb225a562d92e4078ad9728">GPU_MODE</a>, <a class="code" href="carlsim__datastructures_8h.html#ace95bf2edf06bd0708c106dfe43271edab9de27525b1cd54c353f4ed868a6cb26">SILENT</a>);</div>
<div class="line">...</div>
<div class="line">network-&gt;setupNetwork();</div>
<div class="line">...</div>
<div class="line">network-&gt;runNetwork(runTime,0);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">for(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.getNumInstances(); i++) {</div>
<div class="line">...</div>
<div class="line">outputStream &lt;&lt; fitness[i] &lt;&lt; endl;</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="tut7_pti.html">Tutorial 7: Parameter Tuning Interface (PTI)</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h1><a class="anchor" id="ch10s_ecj_options"></a>
10.4 ECJ Extensions</h1>
<p>Most of what you need to know to write an ECJ parameter file is covered in the ECJ manual. PTI does add some non-standard extensions to ECJ, however, which can be used by setting parameters appropriately. This section serves as the canonical reference for these extensions.</p>
<h2><a class="anchor" id="ch10s_ecj_options_simpleGroupedEvaluator"></a>
10.4.1 SimpleGroupedEvaluator</h2>
<p>The core extention that PTI adds to ECJ is a mechanism that allows us to evaluate multiple individuals via a single call to an external simulator. This allows us to, for instance, execute multiple individuals in parallel on a GPU (something that is not possible with ECJ's built-in mechanisms).</p>
<p>To use PTI's grouped evaluation feature, set the <code>eval</code> parameter in the ECJ parameter file like so: </p>
<div class="fragment"><div class="line">eval =  ecjapp.eval.SimpleGroupedEvaluator</div>
</div><!-- fragment --><p> The <code>SimpleGroupedEvaluator</code> class is a version of ECJ's <code>SimpleEvaluator</code> that has been modified so that individuals are evaluated in batches. It accepts the following additional parameters:</p>
<ul>
<li><code>eval.chunk-size</code> (optional):<br/>
 The maximum number of individuals that should be evaluated in each call to the external simulator. You might choose this value, for instance, to the the number of neural networks your GPU card is capable of executing simulataneously.<br/>
</li>
<li><code>eval.measureEvalTimes</code> (optional):<br/>
 If set to <code>true</code>, the number of milliseconds that elapse between generations will be printed. The output is in CSV format. Each row shows the job number, generation, and milliseconds, in that order.<br/>
</li>
<li><code>eval.evalTimesFile</code> (optional):<br/>
 If specified, the times recorded by the <code>measureEvalTimes</code> mechanism will be written to this file instead of to <code>stdout</code>.</li>
</ul>
<p><code>SimpleGroupedEvaluator</code> also responds to the same parameters as <code>SimpleEvaluator</code>, such as <code>num-tests</code> and, importantly, <code>problem</code> (see the ECJ manual).</p>
<dl class="section since"><dt>Since</dt><dd>v3.1</dd></dl>
<h2><a class="anchor" id="ch10s_ecj_options_commandProblem"></a>
10.4.2 CommandProblem</h2>
<p>In ECJ, objective functions are defined by custom implementations of the <code>Problem</code> class. The CARLsim-ECJ jar file includes a special <code>Problem</code> that is meant to be used in conjunction with <code>SimpleGroupedEvaluator</code> to launch an external simulator. This is called <code>CommandProblem</code>, since it launches an external command: </p>
<div class="fragment"><div class="line">eval.problem =  ecjapp.problem.CommandProblem</div>
</div><!-- fragment --><p>This object accepts a number of crucially important parameters:</p>
<ul>
<li><code>eval.problem.simulationCommand</code>:<br/>
 Path to the binary executable for the external simulation. This should be your compiled <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> model.<br/>
</li>
<li><code>eval.problem.errorGenesFile</code>:<br/>
 If the external simulation crashes at any point or produces invalid output, the input (individuals) that caused the error will be recorded to this file. This can be very important for debugging models that behave incorrectly during parameter tuning.<br/>
</li>
<li><code>eval.problem.errorResultsFile</code>:<br/>
 If the external simulation crashes at any point or produces invalid output, the output that cause the error will be recorded to this file. This can be very important for debugging models that behave incorrectly during parameter tuning.<br/>
</li>
<li><code>eval.problem.objective</code>:<br/>
 The <code>ObjectiveFunction</code> that is used to convert the output of the external simulation into a scalar fitness value (See <a class="el" href="ch10_ecj.html#ch10s_ecj_options_objective">10.4.3 ObjectiveFunction</a>).</li>
<li><code>eval.problem.simulationCommandArguments</code> (optional):<br/>
 Additional command-line arguments you would like passed to every invocation of the command. These arguments are constant, and do not change.</li>
<li><code>eval.problem.dynamicArguments</code> (optional):<br/>
 A <code>DynamicArguments</code> for passing information about the evolutionary algorithm's state to the external simulation as command-line arguments (See <a class="el" href="ch10_ecj.html#ch10s_ecj_options_dynamicArguments">10.4.4 DynamicArguments and Multi-GPU Evolution</a>).</li>
<li><code>eval.problem.reevaluate</code> (optional):<br/>
 If set to <code>true</code>, individuals will have their fitness re-evaluated each generation. You may want to reevaluate fitnesses if there is noise in your objective function, for instance. Defaults to <code>false</code>.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>v3.1</dd></dl>
<h2><a class="anchor" id="ch10s_ecj_options_objective"></a>
10.4.3 ObjectiveFunction</h2>
<p>In some applications, it's useful to think of the external simulator as performing a genotype-to-phenotype mapping: the genotype of each individual (a vector of parameters) is mapped to a phenotype that describes the resulting behavior of the simulation. An <code>ObjectiveFunction</code> in PTI's extension of ECJ performs the final step of converting the phenotype value into a scalar fitness value.</p>
<p>Preferably, the phenotype returned by the simulator is just a single scalar value: the individual's fitness. In <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> models, this means that we expect any extraction of features or other data from the SNN execution, and its synthesis into a fitness value, to be performed in the C++ model implementation.</p>
<p>When this is the case, the <code>StringToDoubleObjective</code> object allows ECJ to recognize the output of your model as a stream of fitness values: </p>
<div class="fragment"><div class="line">eval.problem.objective =    ecjapp.eval.problem.objective.StringToDoubleObjective</div>
</div><!-- fragment --><p> This objective accepts one optional parameter:</p>
<ul>
<li><code>eval.problem.objective.idealFitnessValue</code> (optional):<br/>
 When set, an individual will be considered optimal if its fitness is equal to or greater than the specified value.</li>
</ul>
<p>There may be some cases where you wish to perform some post-processing in Java to convert more complex information on a network's behavior into a fitness value. If this is the case, then you may create your own ECJ extention by defining a subclass of <code>ObjectiveFunction</code>. Creating custom classes and using them with ECJ is beyond the scope of this documentation, however.</p>
<dl class="section since"><dt>Since</dt><dd>v3.1</dd></dl>
<h2><a class="anchor" id="ch10s_ecj_options_dynamicArguments"></a>
10.4.4 DynamicArguments and Multi-GPU Evolution</h2>
<p>In some applications, your <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> model may need to know some specific information about the evolutionary algorithm state, beyond the genomes of individuals. In PTI's ECJ extension, a <code>DynamicArguments</code> object plays the role of taking data from variables in ECJ and sending it to the simulator as command-line arguments.</p>
<p>One important use of <code>DynamicArguments</code> is to invoke different simultaneous <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> instances on different GPU cards. The <code>ThreadDynamicArguments</code> object makes this possible by passing a thread ID to each instance of the simulator that is launched in a generation.</p>
<p>Say, for example, that your evolutionary algorithm produces 100 children, but that you can only evaluated 50 individuals at a time in your simulation. If you have set <code>eval.chunk-size = 50</code>, and if you have configured ECJ to use 2 evaluation threads, then two threads will be launched, each of which will send its 50 individuals to your <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> model to be evaluated on a GPU. <code>ThreadDynamicArguments</code> will assign one of these simulations a thread ID of 0, and the other one a thread ID of 1. </p>
<div class="fragment"><div class="line">eval.problem.dynamicArguments = ecjapp.eval.problem.ThreadDynamicArguments</div>
</div><!-- fragment --><p> The following parameters are available when using this mechanism:</p>
<ul>
<li><code>eval.problem.dynamicArguments.option</code>:<br/>
 The name of the command-line option to pass the thread ID to.</li>
<li><code>eval.problem.dynamicArguments.modulo</code> (optional):<br/>
 If specified, the thread ID modulo this value will be passed. Use this if you are using more evaluation threads than the number of GPUs you have available.</li>
<li><code>eval.problem.dynamicArguments.dynamicArguments</code> (optional):<br/>
 Another <code>DynamicArguments</code> object. Use this if you want to chain arguments together to pass more information to the simulator.</li>
</ul>
<p>If, for instance, <code>option</code> is set to '<code>-device</code>', then the simulator launched by thread 1 will have the argument '<code>-device 1</code>' passed to it as a command-line option.</p>
<p>PTI's ECJ extension also includes a <code>DynamicArguments</code> for telling the simulator what generation the evolutionary algorithm is on: </p>
<div class="fragment"><div class="line">eval.problem.dynamicArguments = ecjapp.eval.problem.GenerationDynamicArguments</div>
</div><!-- fragment --><p> It accepts the following parameters:</p>
<ul>
<li><code>eval.problem.dynamicArguments.option</code>:<br/>
 The name of the command-line option to pass the generation number to.</li>
<li><code>eval.problem.dynamicArguments.dynamicArguments</code> (optional):<br/>
 Another <code>DynamicArguments</code> object. Use this if you want to chain arguments together to pass more information to the simulator.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>v3.1</dd></dl>
<h2><a class="anchor" id="ch10s_ecj_options_statistics"></a>
10.4.5 Recording Statistics</h2>
<p>By default, ECJ produces an <code>out.stat</code> file that records the genome and fitness of the best individual in each generation, and of the best individual from the entire run. When it comes time to analyze the results of an EA, this file can be difficult to parse, and it may not contain all the information you need.</p>
<p>PTI's extension provides two addition ECJ <code>Statistics</code> objects that you may use to collect and store commonly-needed EA data in CSV format: <code>ecjapp.statistics.FitnessStatistics</code> and <code>ecjapp.statistics.DoubleVectorGenomeStatistics</code>.</p>
<p>To add a <code>Statistics</code> class to an EA configuration, we add them as <em>children</em> of the default <code>stat</code> object. To do so, first specify the number of children you wish to add, and then define the parameters for each child. In the following example we configure ECJ to collect both <code>FitnessStatistics</code> and <code>DoubleVectorGenomeStatistics</code>.</p>
<div class="fragment"><div class="line">stat.num-children = 2</div>
<div class="line">stat.child.0 =                          ecjapp.statistics.FitnessStatistics</div>
<div class="line">stat.child.0.file =                     $fitness.csv</div>
<div class="line">stat.child.1 =                          ecjapp.statistics.DoubleVectorGenomeStatistics</div>
<div class="line">stat.child.1.pVectorLength =        pop.subpop.0.species.genome-size</div>
<div class="line">stat.child.1.file =                     $genomes.csv</div>
</div><!-- fragment --><p><code>FitnessStatistics</code> records the minimum, maximum, and average fitness, and the standard deviation of fitnesses in the entire population at each generation. It also records the time (in milliseconds) that each generation finished evaluating. Alternatively, <code>FitnessStatistics</code> can be used to record the fitness of every individual in the population (see the <code>individuals</code> option below).</p>
<p>The following parameters are available for configuring <code>FitnessStatistics</code>:</p>
<ul>
<li><code>stat.child.0.file</code>:<br/>
 Name of the output file to write CSV data to. The fill will be created if it does not already exist. Prefixing the file name with a dollar sign ('$') indicates that it should be saved in the current directory. If you are running multiple runs of the EA (i.e. via the <code>jobs</code> parameter), then the filename will be prefixed with 'job.[jobnumber].', and one file will be created for each job.</li>
<li><code>stat.child.0.gzip</code> (optional):<br/>
 If true, the data will be compressed with <code>gzip</code>.</li>
<li><code>stat.child.0.individuals</code> (optional):<br/>
 If true, the fitness of every individual in the population will be recorded, instead of summary statistics. The resulting CSV will have 4 columns instead of the usual 7, with one row per individual per generation.</li>
</ul>
<p><code>DoubleVectorGenomeStatistics</code> records the genome and fitness of <em>all</em> individuals in the population. The following parameters are available:</p>
<ul>
<li><code>stat.child.1.file</code><br/>
 Name of the output file to write CSV data to. The fill will be created if it does not already exist. Prefixing the file name with a dollar sign ('$') indicates that it should be saved in the current directory. If you are running multiple runs of the EA (i.e. via the <code>jobs</code> parameter), then the filename will be prefixed with '<code>job.[jobnumber].</code>', and one file will be created for each job.</li>
<li><code>stat.child.1.pVectorLength</code>:<br/>
 The name of a <em>parameter</em> whose value indicates the number of parameters in the genome. This tells <code>DoubleVectorGenomeStatistics</code> how many parameter columns need to be in its output. Typically you'll want to point this to the <code>genome-size</code> parameter of your species.</li>
<li><code>stat.child.1.compress</code> (optional):<br/>
 If true, the data will be compressed with <code>gzip</code>.</li>
<li><code>stat.child.1.initOnly</code> (optional):<br/>
 If true, only the genomes of the initial population will be recorded.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>v3.1</dd></dl>
<h1><a class="anchor" id="ch10s_ecj_tricks"></a>
10.5 Tips and Tricks</h1>
<h2><a class="anchor" id="ch10s_ecj_tricks_getBest"></a>
10.5.1 Retrieving Genomes of the Best Individuals</h2>
<p>After running an evolutionary algorithm a number of times to tune a spiking neural network, we often wish to retrieve the best individual found in each run for further analysis. This can be done by examining the output recorded by <code>DoubleVectorGenomeStatistics</code> and finding the individual with the highest fitness.</p>
<p>Alternatively, the following shell script can be copied and pasted to automatically extract the best individual. It assumes that we have run ECJ for 10 jobs, and that the output of <code>DoubleVectorGenomeStatistics</code> has been written to files named '<code>job.[num].genomes.csv</code>', where <code>[num]</code> ranges from 0 to 9:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> j in {0..9}; <span class="keywordflow">do</span></div>
<div class="line">    (echo â€˜cat job.$j.genomes.csv | tail -n+2 | sort -rk3 -t, | head -n1 | cut -d, -f4-â€˜ &gt; bestInd$j.csv);</div>
<div class="line">done;</div>
</div><!-- fragment --><h2><a class="anchor" id="ch10s_ecj_tricks_withoutECJ"></a>
10.5.2 Evaluating Individuals Outside of ECJ</h2>
<p>Equally often, we want to run and analyze a simulation using high-fitness parameters that were found by ECJ.</p>
<p>Because PTI models use the stanard input stream to receive simulation parameters, you can always execute your simulation with any set of parameters by piping the vector of parameters into the simulation. For instance, if I want to use the parameters '<code>0.1, 0.2, 0.3, 0.4, 0.5</code>' to run a simulation whose binary is named '<code>carlsim_myModel</code>', then I can do so like this:</p>
<div class="fragment"><div class="line">echo <span class="stringliteral">&quot;0.1,0.2,0.3,0.4,0.5&quot;</span> | ./carlsim_myModel</div>
</div><!-- fragment --><p>Similarly, if I would like to run several networks in parallel with the same parameters, I can repeat the parameter vector several times: </p>
<div class="fragment"><div class="line">(<span class="keywordflow">for</span> i in {1..40}; <span class="keywordflow">do</span> echo <span class="stringliteral">&quot;0.1,0.2,0.3,0.4,0.5&quot;</span>; done) | ./carlsim_myModel</div>
</div><!-- fragment --><p>Say that I have stored the best genome found from each run in a file, as described in the previous section. Perhaps my fitness evaluation is rather noisy, and I want to get a good estimate of the true expected fitness value of each job's best individual. With the following script, I can take 40 fitness samples from each job's best individual in parallel: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> j in {0..9}; <span class="keywordflow">do</span></div>
<div class="line">    (<span class="keywordflow">for</span> i in {1..40}; <span class="keywordflow">do</span> cat bestInd$j.csv; done) | ./carlsim_myModel</div>
<div class="line">done;</div>
</div><!-- fragment --><h1><a class="anchor" id="ch10s4_references"></a>
References</h1>
<p>Beyeler, M., Carlson, K. D., Chou, T. S., Dutt, N., Krichmar, J. L., <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> 3: A user-friendly and highly optimized library for the creation of neurobiologically detailed spiking neural networks. (Submitted)</p>
<p>Carlson, K. D., Nageswaran, J. M., Dutt, N., Krichmar, J. L., An efficient automated parameter tuning framework for spiking neural networks, Front. Neurosci., vol. 8, no. 10, 2014.</p>
<p>Luke, S., Panait, L., Balan, G., Paus, S., Skolicki, Z., Bassett, J., Hubley, R., and Chircop, A., ECJ: A java-based evolutionary computation research system, <a href="http://cs.gmu.edu/eclab/projects/ecj">http://cs.gmu.edu/eclab/projects/ecj</a>, 2006. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 6 2017 13:12:24 for CARLsim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
