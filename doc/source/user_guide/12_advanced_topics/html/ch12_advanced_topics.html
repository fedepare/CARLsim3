<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Chapter 12: Advanced Topics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Chapter 12: Advanced Topics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ch12s1_best_practices">12.1 Best Practices</a><ul><li class="level2"><a href="#ch12s1s1_tips_tricks">12.1.1 Tips and Tricks, Do&#39;s and Don&#39;ts</a></li>
<li class="level2"><a href="#ch12s1s2_speed_up">12.1.2 Ways to Speed Up Your Simulation</a></li>
</ul>
</li>
<li class="level1"><a href="#ch12s2_num_int">12.2 Numerical Integration Methods</a><ul><li class="level2"><a href="#ch12s2s1_euler">12.2.1 Euler Method</a></li>
<li class="level2"><a href="#ch12s2s2_RK4">12.2.2 Runge-Kutta Method</a></li>
</ul>
</li>
<li class="level1"><a href="#ch12s3_multi_gpu">12.3 Multi-GPU Support</a></li>
<li class="level1"><a href="#ch12s4_online_weight_tuning">12.4 On-Line Weight Tuning</a><ul><li class="level2"><a href="#ch12s4s1_simple_weight_tuner">12.4.1 Simple Weight Tuner</a></li>
<li class="level2"><a href="#ch12s4s2_set_weight">12.4.2 Setting the Weight of a Single Synapse</a></li>
<li class="level2"><a href="#ch12s4s3_bias_weights">12.4.3 Add a Bias to All the Weights of a Connection</a></li>
<li class="level2"><a href="#ch12s4s4_scale_weights">12.4.4 Scale All the Weigths of a Connection</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ch12s1_best_practices"></a>
12.1 Best Practices</h1>
<h2><a class="anchor" id="ch12s1s1_tips_tricks"></a>
12.1.1 Tips and Tricks, Do's and Don'ts</h2>
<p>SpikeMonitors and ConnectionMonitors, while very useful, can easily slow simulations down. They should be used for brief periods of time as opposed to the entire duration of the simulation. Additonally, it makes sense to target the exact group or connection you care about as opposed to all neurons or synapses in the simulation.</p>
<h2><a class="anchor" id="ch12s1s2_speed_up"></a>
12.1.2 Ways to Speed Up Your Simulation</h2>
<p>As mentioned above, leaving Spike or ConnectionMonitors on running for a long period of time or over a large group of neurons will slow the simulation down dramatically. Although many state variables are updated every timestep (ms), CARLsim performs more calculations as the number of spikes grow. Therefore simulations with high firing rates will necessarily slow the simulation down as well. A common trick to speed up simulations that have a training and testing phase is to train the SNN and then output the network state (with synaptic weights) to preserve the training using saveSimulation. The network state can then be reloaded using loadSimulation. In this way, users can load a pre-trained network anytime they wish without incurring the cost of training.</p>
<dl class="section see"><dt>See also</dt><dd>ch7s1_spike_monitor</dd></dl>
<h1><a class="anchor" id="ch12s2_num_int"></a>
12.2 Numerical Integration Methods</h1>
<p>CARLsim currently supports forward-Euler and fourth-order Runge Kutta for the numerical integration of ODEs.</p>
<p>The integration method and integration time step can be specified via CARLsim::setIntegrationMethod. By default, the simulation uses forward-Euler with a basic integration step of 0.5ms.</p>
<p>The specified integration method will apply to all neurons in the network. Future CARLsim versions might allow to specify the integration method on a per-group basis.</p>
<p>In contrast to the <em>integration</em> time step, the <em>simulation</em> time step is always 1ms, meaning that spike times cannot be retrieved with sub-millisecond precision. Future CARLsim versions might allow for sub-millisecond spike times.</p>
<h2><a class="anchor" id="ch12s2s1_euler"></a>
12.2.1 Euler Method</h2>
<p>By default, CARLsim uses the forward (or standard) Euler method with an integration step of 0.5ms for numerical stability. This can be set explicitly with the following function call:</p>
<div class="fragment"><div class="line">sim.setIntegrationMethod(FORWARD_EULER, numStepsPerMs);</div></div><!-- fragment --><p>where <code>numStepsPerMs</code> is the number of integration steps to perform per 1ms.</p>
<p>We suggest the number of time steps be at least 2 when working with the 4-parameter Izhikevich model (see ch3s1s1_izhikevich_neurons4). We do not recommend to use forward-Euler when working with the 9-parameter Izhikevich or compartmental models (see ch3s1s2_izhikevich_neurons9 and ch3s1s3_compartments).</p>
<dl class="section note"><dt>Note</dt><dd>The recovery variable of the Izhikevich model is always integrated using forward-Euler. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ch3s1_neurons </dd>
<dd>
<a class="el" href="ch12_advanced_topics.html#ch12s2s2_RK4">12.2.2 Runge-Kutta Method</a></dd></dl>
<h2><a class="anchor" id="ch12s2s2_RK4"></a>
12.2.2 Runge-Kutta Method</h2>
<dl class="section author"><dt>Author</dt><dd>Stanislav Listopad </dd>
<dd>
Michael Beyeler</dd></dl>
<p>CARLsim also supports the use of fourth-order Runge-Kutta (also referred to as "RK4", "classical Runge-Kutta method", or simply as "\em the Runge-Kutta method").</p>
<p>This can be specified with the following function call:</p>
<div class="fragment"><div class="line">sim.setIntegrationMethod(RUNGE_KUTTA4, numStepsPerMs);</div></div><!-- fragment --><p>where <code>numStepsPerMs</code> is the number of integration steps to perform per 1ms.</p>
<p>We suggest the number of time steps be at least 10 when working with compartmental neurons (see ch3s1s3_compartments).</p>
<dl class="section note"><dt>Note</dt><dd>Note that the higher numStepsPerMs the slower the simulation may be, due to increased computational load. </dd>
<dd>
The recovery variable of the Izhikevich model is always integrated using forward-Euler. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.1</dd></dl>
<h1><a class="anchor" id="ch12s3_multi_gpu"></a>
12.3 Multi-GPU Support</h1>
<p>CARLsim is now threadsafe so a distinct CARLsim simulation can be run on every GPU device on the machine.</p>
<p>Full multi-GPU support will be added in CARLsim 4.</p>
<h1><a class="anchor" id="ch12s4_online_weight_tuning"></a>
12.4 On-Line Weight Tuning</h1>
<dl class="section author"><dt>Author</dt><dd>Michael Beyeler</dd></dl>
<p>CARLsim provides a range of handy functions to change weight values on the fly; that is, without having to recompile the network. The utility SimpleWeightTuner implements a simple weight search algorithm inspired by the bisection method. The function CARLsim::setWeight allows a user to change the weight of a single synapse. Alternatively, CARLsim::biasWeights can be used to add a constant bias to every weight of a certain connection ID, and CARLsim::scaleWeights multiplies all the weights with a scaling factor.</p>
<p>These functions are useful especially for tuning feedforward weights in large-scale networks that would otherwise take a lot of time to repeatedly build. For tuning in more complex situations please refer to ch10_ecj.</p>
<p>These functions are only valid in ::carlsimState_t ::RUN_STATE and do not alter the topography of the network. They apply to weight values of already allocated synapses only.</p>
<dl class="section see"><dt>See also</dt><dd>ch10_ecj</dd></dl>
<h2><a class="anchor" id="ch12s4s1_simple_weight_tuner"></a>
12.4.1 Simple Weight Tuner</h2>
<p>The SimpleWeightTuner utility is a class that allows tuning of weight values of a specific connection (i.e., a collection of synapses), so that a specific neuron group fires at a predefined target firing rate&mdash;without having to recompile the CARLsim network.</p>
<p>A complete example is explained in tut4_simple_weight_tuner.</p>
<p>Consider a CARLsim network with an input group (<code>gIn</code>) connected to an output group (<code>gOut</code>). Suppose the goal is to find weight values that lead to some desired output activity (say, 27.4Hz), in response to some Poissonian input. A conventional approach to solving this problem would be to repeatedly build and run the network with different weight values, until some values are found that let <code>gOut</code> approach the desired target firing rate. This process can be tedious, especially when dealing with large-scale networks that take a long time to build.</p>
<p>Instead, one can use a SimpleWeightTuner: </p><div class="fragment"><div class="line">SimpleWeightTuner SWT(sim, 0.01, 100); <span class="comment">// CARLsim object, error margin, max iterations</span></div><div class="line">SWT.setConnectionToTune(c0, 0.0);      <span class="comment">// connection to tune, initial weight</span></div><div class="line">SWT.setTargetFiringRate(gOut, 27.4);   <span class="comment">// output group to observe, target firing rate (Hz)</span></div></div><!-- fragment --><p> The SimpleWeightTuner constructor accepts a pointer to the above created network <code>sim</code> and some termination conditions: The algorithm will terminate if either the absolute error between observed firing rate and target firing rate is smaller than some error margin, or upon reaching the maximum number of iterations. Calling SimpleWeightTuner::setConnectionToTune informs the class about which connection to tune and with which weight to start. The algorithm will repeatedly change the weights in a way that resembles the bisection method, until the mean firing rate of group <code>gOut</code> reaches 27.4 +- 0.01 Hz (specified via SimpleWeightTuner::setTargetFiringRate). Note that the here involved connection (<code>c0</code>) and neuron group (<code>gOut</code>) can be completely independent from each other.</p>
<p>All that is left to do is to execute the algorithm until finished: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (!SWT.done()) {</div><div class="line">    SWT.iterate();</div><div class="line">}</div></div><!-- fragment --><p> This will run <code>sim</code> repeatedly for one second (for different time periods pass an optional argument) until one of the termination criteria is reached.</p>
<dl class="section note"><dt>Note</dt><dd>The connection to tune and the neuron group for which a target firing rate are found do not have to be associated with each other. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ch10_ecj </dd>
<dd>
tut4_simple_weight_tuner </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h2><a class="anchor" id="ch12s4s2_set_weight"></a>
12.4.2 Setting the Weight of a Single Synapse</h2>
<p>The easiest way to change the weight of a synapse is CARLsim::setWeight: </p><div class="fragment"><div class="line"><span class="comment">// must be in RUN state</span></div><div class="line">sim.runNetwork(1,0);</div><div class="line"></div><div class="line"><span class="comment">// remember connId from connect call</span></div><div class="line"><span class="comment">// change the weight from first pre-neuron to fifth post-neuron to 0.25f</span></div><div class="line"><span class="comment">// make sure this synapse this allocated!</span></div><div class="line">sim.setWeight(connId, 0, 4, 0.25f);</div></div><!-- fragment --><p> This function will set the weight of a particular synapse of connection ID <code>connId</code>, namely the synapse connecting neuron <code>neurIdPre</code> to neuron <code>neurIdPost</code>, to value <code>weight</code>. Here, the connection ID is the return argument of the corresponding CARLsim::connect call. Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.</p>
<p>If the specified weight lies outside the boundaries <code>[minWt,maxWt]</code> of RangeWeight, then two different behaviors can be achieved, depending on a fifth optional argument <code>updateWeightRange</code>.</p><ul>
<li>If <code>updateWeightRange</code> is set to <code>true</code>, then the corresponding weight boundaries <code>[minWt,maxWt]</code> will be updated should the specified weight lie outside those boundaries.</li>
<li>If <code>updateWeightRange</code> is set to <code>false</code>, then the corresponding weight will be clipped so that it stays within the existing weight boundaries <code>[minWt,maxWt]</code>.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Make sure this function is called on a synapse that actually exists! </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h2><a class="anchor" id="ch12s4s3_bias_weights"></a>
12.4.3 Add a Bias to All the Weights of a Connection</h2>
<p>Alternatively, it is possible to change the weights of all the synapses that belong to a certain connection ID using CARLsim::biasWeights: </p><div class="fragment"><div class="line"><span class="comment">// must be in RUN state</span></div><div class="line">sim.runNetwork(1,0);</div><div class="line"></div><div class="line"><span class="comment">// remember connId from connect call</span></div><div class="line"><span class="comment">// add 0.125 to all allocated synapses of connId</span></div><div class="line"><span class="comment">// set updateWeightRange flag to true in order to update [minWt,maxWt] if necessary</span></div><div class="line">sim.biasWeights(connId, 0.125f, <span class="keyword">true</span>);</div></div><!-- fragment --><p> This function will add a constant <code>bias</code> to the weight of every synapse of connection ID <code>connId</code>. Here, the connection ID is the return argument of the corresponding CARLsim::connect call. Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.</p>
<p>If the new weight (old weight plus bias) lies outside the boundaries <code>[minWt,maxWt]</code> of RangeWeight, then two different behaviors can be achieved, depending on a third optional argument <code>updateWeightRange</code>.</p><ul>
<li>If <code>updateWeightRange</code> is set to <code>true</code>, then the corresponding weight boundaries <code>[minWt,maxWt]</code> will be updated should the new weight lie outside those boundaries.</li>
<li>If <code>updateWeightRange</code> is set to <code>false</code>, then the corresponding weight will be clipped so that it stays within the existing weight boundaries <code>[minWt,maxWt]</code>.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h2><a class="anchor" id="ch12s4s4_scale_weights"></a>
12.4.4 Scale All the Weigths of a Connection</h2>
<p>Alternatively, it is possible to change the weights of all the synapses that belong to a certain connection ID using CARLsim::scaleWeights: </p><div class="fragment"><div class="line"><span class="comment">// must be in RUN state</span></div><div class="line">sim.runNetwork(1,0);</div><div class="line"></div><div class="line"><span class="comment">// remember connId from connect call</span></div><div class="line"><span class="comment">// multiply all allocated synapses of connId with scaling factor 1.345</span></div><div class="line"><span class="comment">// set updateWeightRange flag to true because it will be necessary to update [minWt,maxWt]</span></div><div class="line">sim.scaleWeights(connId, 1.345f, <span class="keyword">false</span>);</div></div><!-- fragment --><p> This function will multiply the weight of every synapse of connection ID <code>connId</code> with a scaling factor <code>scale</code>. Here, the connection ID is the return argument of the corresponding CARLsim::connect call. Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.</p>
<p>If the new weight (old weight times scaling factor) lies outside the boundaries <code>[minWt,maxWt]</code> of RangeWeight, then two different behaviors can be achieved, depending on a third optional argument <code>updateWeightRange</code>.</p><ul>
<li>If <code>updateWeightRange</code> is set to <code>true</code>, then the corresponding weight boundaries <code>[minWt,maxWt]</code> will be updated should the new weight lie outside those boundaries.</li>
<li>If <code>updateWeightRange</code> is set to <code>false</code>, then the corresponding weight will be clipped so that it stays within the existing weight boundaries <code>[minWt,maxWt]</code>.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
