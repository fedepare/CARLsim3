<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Chapter 2: Basic Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Chapter 2: Basic Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ch2s1_general_workflow">2.1 General Workflow</a><ul><li class="level2"><a href="#ch2s1s1_config">2.1.1 The CONFIG State</a></li>
<li class="level2"><a href="#ch2s1s2_setup">2.1.2 The SETUP State</a></li>
<li class="level2"><a href="#ch2s1s3_run">2.1.3 The RUN State</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ch2s1_general_workflow"></a>
2.1 General Workflow</h1>
<dl class="section author"><dt>Author</dt><dd>Michael Beyeler</dd></dl>
<p>The workflow of a typical CARLsim 3 simulation is organized into three distinct, consecutive states (see figure below): the configuration state, the set up state, and the run state.</p>
<p>User functions in the C++ API are grouped according to these stages, which streamline the process and prevent race conditions. State transitions are handled by special user functions such as CARLsim::setupNetwork and CARLsim::runNetwork.</p>
<div class="image">
<img src="2_carlsim_states.jpg" alt="2_carlsim_states.jpg"/>
<div class="caption">
A diagram showing the possible states the CARLsim simulation can occupy.</div></div>
<p> The first step in using CARLsim 3 (<code>libCARLsim</code>) imports the library and instantiates the main simulation object: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;carlsim.h&gt;</span></div><div class="line">CARLsim sim(<span class="stringliteral">&quot;example&quot;</span>, GPU_MODE, USER);</div></div><!-- fragment --><p> This prepares the simulation for execution in either ::CPU_MODE or ::GPU_MODE, and specifies the verbosity of the status reporting mechanism (::USER indicating the default logger mode that will print info and error messages to console and save debug messages in a text file). Other logger modes are available that print only error messages (::SHOWTIME), suppress console output alltogether (::SILENT), or allow to set custom file pointers for each message type (::CUSTOM).</p>
<p>The ability to run a network either on standard x86 CPUs (::CPU_MODE) or off-the-shelf NVIDIA GPUs (::GPU_MODE) allow the user to exploit the advantages of both architectures. Whereas the CPU is more efficient for relatively small networks, the GPU is most advantageous fo rnetwork sizes of 10,000 neurons and up. In this regime, GPU mode should significantly outperform CPU mode (with roughly a factor of 20). On the other hand, CPU mode allows for execution of extremely large networks that would not fit within the GPU's memory.</p>
<p>In addition, the user may want to specify on which CUDA device to run the simulation. For this, the CARLsim constructor allows specification of a "device index" (<code>ithGPU</code>, which can be used in multi-GPU systems to specify on which CUDA device to establish context. For example, in order to run a network on the third GPU in the system (<code>ithGPU=2</code>, 0-indexed) and use random seed 42, the constructor should be called as follows: </p><div class="fragment"><div class="line">CARLsim sim(<span class="stringliteral">&quot;example&quot;</span>, GPU_MODE, USER, 2, 42);</div></div><!-- fragment --><p>From then on, the simulation is in ::CONFIG_STATE, allowing the properties of the neural network to be specified.</p>
<h2><a class="anchor" id="ch2s1s1_config"></a>
2.1.1 The CONFIG State</h2>
<dl class="section author"><dt>Author</dt><dd>Michael Beyeler</dd></dl>
<p>Similar to PyNN and many other simulation environments, CARLsim uses groups of neurons (see ch3_neurons_synapses_groups) and connections (see ch4_connections) as an abstraction to aid defining synaptic connectivity. Different groups of neurons can be created from a one-dimensional array to a three-dimensional grid (see ch3s3s2_topography) via CARLsim::createSpikeGeneratorGroup or CARLsim::createGroup, and connections can be specified depending on the relative placement of neurons via CARLsim::connect. This allows for the creation of networks with complex spatial structure.</p>
<p>The present release allows users to choose from a number of synaptic plasticity mechanisms (see ch5_synaptic_plasticity). These include standard equations for STP (see ch5s1_short_term_plasticity), various forms of nearest-neighbor STDP (see ch5s2_spike_timing_dependent_plasticity), and homeostatic synaptic plasticity in the form of synaptic scaling (see ch5s3_homeostasis).</p>
<p>For a selective list of available function calls in ::CONFIG_STATE, please refer to the left-hand side of the above figure.</p>
<h2><a class="anchor" id="ch2s1s2_setup"></a>
2.1.2 The SETUP State</h2>
<dl class="section author"><dt>Author</dt><dd>Michael Beyeler</dd></dl>
<p>Once the spiking network has been specified, the function CARLsim::setupNetwork optimizes the network state for the chosen back-end (CPU or GPU) and moves the simulation into ::SETUP_STATE.</p>
<p>In this state, a number of monitors (see ch7_monitoring) can be set up to record variables of interest (e.g., spikes, weights, state variables) in binary files for off-line analysis (see ch9_matlab_oat). New in CARLsim 3 is a means to make these data available at run-time (without the computational overhead of writing data to disk), which can be queried for data in the ::RUN_STATE.</p>
<p>For example, Spike Monitors can be used to record output spikes for different neuronal groups (see ch7s1_spike_monitor) either to a spike file (binary) or to a SpikeMonitor object. The former is useful for off-line analysis of activity (e.g., using ch9_matlab_oat). The latter is useful to calculate different spike metrics and statistics on-line, such as mean firing rate and standard deviation, or the number of neurons whose firing rate lies in a certain interval.</p>
<p>Similar monitors exist to record weights (see ch7s2_connection_monitor). More monitors will be added in the future.</p>
<h2><a class="anchor" id="ch2s1s3_run"></a>
2.1.3 The RUN State</h2>
<dl class="section author"><dt>Author</dt><dd>Michael Beyeler</dd></dl>
<p>The first call to CARLsim::runNetwork will take the simulation into ::RUN_STATE. The simulation can be repeatedly run (or "stepped") for an arbitrary number of <code>sec</code>*1000 + <code>msec</code> milliseconds: </p><div class="fragment"><div class="line">sim.runNetwork(sec, msec);</div></div><!-- fragment --><p>Input can be generated via current injection (see ch6s2_generating_current) or spike injection (see ch6s1_generating_spikes). We also provide plug-in code to create Poisson spike trains from animated visual stimuli such as sinusoidal gratings, plaids, and random dot fiels via the VisualStimulus MATLAB toolbox (see ch6s3_visual_stimulus_toolbox).</p>
<p>Once a network has reached ::CONFIG_STATE or ::RUN_STATE, the network state can be stored in a file for later processing or for restoring a specific network (see ch8_saving_loading). The network state consists of all the synaptic connections, weights, delays, and whether the connections are plastic or fixed. Furthermore, the network can be stored after synaptic learning has occurred in order to externally analyze the learned synaptic patterns (for example, via a MATLAB ConnectionMonitor; see ch9s4_connection_monitor).</p>
<p>As more complex biological features are integrated into spiking network models, it becomes increasingly important to provide users with a method of tuning the large number of open parameters. To this end, CARLsim 3 provides a paramer tuning interface that uses evolutionary algorithms to optimize a generic fitness function (see ch10_ecj). A more modest approach is to use the SimpleWeightTuner utility that changes weights on-the-fly such that a certain group fires at a predefined target firing rate (see ch12s4_online_weight_tuning).</p>
<p>As mentioned before, once a network has been run, its activity and structure can be visualized using an Offline Analysis Toolbox (OAT) written in MATLAB (see ch9_matlab_oat). In addition, the OAT provides means to access the saved data programmatically, and to store generated sequences of plots as an AVI file.</p>
<dl class="section see"><dt>See also</dt><dd>tut1_basic_concepts </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
